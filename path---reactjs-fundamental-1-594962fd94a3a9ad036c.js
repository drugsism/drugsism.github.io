webpackJsonp([0xf6be5ff1a7cc],{774:function(e,t){e.exports={data:{post:{id:"/Users/drugsism/Documents/Persnal/sopesnote/content/posts/2018-02-13--Reactjs-Fundamental-1/index.md absPath of file >>> MarkdownRemark",html:'<p><br /><br /></p>\n<p align="center">\n<img src="https://www.import.io/wp-content/uploads/2017/10/React-logo-300x140.png">\n</p>\n<p><br /><br /></p>\n<blockquote>\n<p>최근 몇년 동안 웹개발 관련 기술은 수많은 변화를 격고있다.</p>\n</blockquote>\n<p>어느 산업과 마찬가지로 기술을 이끌어가는 큰 벤더들이 서비스 하는 웹서비스에 발마추어 브라우져 버전 또한 과거에 비해 큰 규모의 업데이트가 적용 되고 있으며, 서버, 디바이스등 하드웨어의 발전과 맞물려 웹기술은 환경에 따른 한계에서 어느정도 자유로워진 부분도 큰 이유 중 하나이다. </p>\n<p>그 변화의 중심에는 <code class="language-text">Javascript</code>가 있다고 해도 과언이 아닐것이다.</p>\n<p>Javascript는 과거 HTML문서의 vaildation처리 정도의 수준에서 활용되었지만, 브라우져 없이 서버에서 작동하고 코드가 간결하며, 상대적으로 빠른 도입과 적용이 가능하게 되면서 많은 사이트가 자바스크립트 프레임 워크, 라이브러리를 사용하여 개발 되고 프레임워크가 변경되고 새로운 라이브러리가 나오고 있다.</p>\n<p>프론트엔드에서  템플릿, 모델, 이벤트를 분리하여 Client side MVC패턴으로 개발을 할 수있는 <a href="https://backbonejs.org">Backbone.js</a>라이브러리가 인기를 얻으면서 본격적인 프론트엔드 프레임워크들이 발표된다. 대표적으로 <a href="https://emberjs.com">Ember</a>, <a href="https://knockoutjs.com/">Knockout</a> 그리고 <a href="https://Angularjs.org">Angular JS</a>가 발표되어 끝판왕으로 군림한다.</p>\n<p>AngularJS는 개발속도, Javascript의 코드량 축소, MVC패턴으로 얻는 장점(코드 컨벤션등) 그밖에 많은 장점을 갖고 있으며, 모바일에서 속도 문제, 러닝커브, 페이지 깜빡임, 뒤로가기시 새로로딩, 외부 서비스 콜백처리의 모호함 - 새로운 버전에서 많은 부분이 개선됨 - 등의 단점이 있다. 하지만 몇번의 업데이트 이슈와 여전히 존재하는 단점에도 불구하고 인기가 있고 여전히 많은 웹 서비스에서 사용되고 있다.</p>\n<p>그리고 2013년 Facebook에서 <code class="language-text">React</code>를 발표한다.</p>\n<p>React는 MVC프레임워크는 아니고 User Interface(View)를 만드는 라이브러리다. AngularJS처럼 MVC를 표방하는 것이 아니라 V(iew)에 집중하였고 훨씬 가볍다.</p>\n<br/>\n<blockquote>\n<p>React의 장점</p>\n</blockquote>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">- 쉽다(시작하기). 자바스크립트다. 당신이 ES6에 익숙하다면.(반대한다 이유는 React의 단점에서 기술)\n- 빠르다. DOM대신 Virtual DOM이라는 걸 이용하여 리플로우를 최소화한다.\n- 단순하다. 단방향 플로우로 프로젝트의 복잡성을 해소하고 Component를 구성하기 쉬움.\n- ES6지원 좋음\n- 일부페이지에 큰 수정없이 바로 적용할 수 있음 </code></pre>\n      </div>\n<p>위 항목 중 무었보다 큰 장점을 꼽자면 단언 <code class="language-text">Virtual DOM</code> 이다.</p>\n<br/>\n<blockquote>\n<p>Virtual DOM </p>\n</blockquote>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">Facebook에서는 DOM을 직접 변경하지 않고 내부적으로 빠르게 diff를 계산하는 알고리즘을 고안한다. \n마치 git을 사용하듯이 변경된 부분만 찾아서 빠르게 화면을 렌더링 할 수 있게 해준다.</code></pre>\n      </div>\n<p>브라우져는 보통 다음과 같은 과정을 통해 화면을 그려낸다.</p>\n<br>\n<p align="center">\n<img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/webkitflow.png">\n</p>\n<br>\n<p>외부에서 DOM의 변경이 일어나면 DOM Tree를 재구성하고 Attachment하여 Render Tree를 재구성한다. 이때 브라우져가 판단하여 리플로(Layout), 리페인트(Painting)이 일어난다.</p>\n<br/>\n<p>Virtual DOM을 사용한 React에서는 같은 간단한 예시로 어떻게 최적화하는지 볼 수있다.</p>\n<div class="gatsby-highlight" data-language="text">\n      <pre class="language-text"><code class="language-text">class Hello extends Component {\n    constructor(props) {\n        super(props);\n        ....\n    };\n    render() {\n        return(\n            // JSX\n            &lt;react.fragment&gt;\n                &lt;div&gt;Hello {this.props.personName} &lt;/div&gt;\n                &lt;div&gt;My name is {this.state.name}&lt;/div&gt;\n            &lt;/react.fragment&gt;\n        );\n    }\n}</code></pre>\n      </div>\n<p>이 Hello 클래스는 만약 this.props.personName이 ‘James’이고 this.state.name이 ‘Jessie’ 라면 “Hello James” “My name is Jessie”라는 문자를 리턴하여 보여주는 컴포넌트 라고 하자.\n만약 <strong>this.state.name</strong>이 “Tom”으로 바뀐다면 당연히 “Hello James” “My name is Tom” 이렇게 출력 될 것이다. </p>\n<p>이때 React에서는 일반 브라우져의 리렌더링 과정과 다른 과정이 일어나는데 바로 Virtual DOM이 사용된다.\n기존 Component Tree의 DOM과 현재 변경된 Componenet를 비교하여 변경된 Component만 변경하고 DOM자체를 갱신한다.(심지어 알고리즘을 통해 비교하여 컴포넌트는 사라지지않고 속성값만 변경한다)</p>\n<p>이로 인해 브라우져의 리플로를 최소화되고 성능을 최대화 할수있다.</p>\n<p>프레임워크에 비해 상대적으로 가벼운 라이브러리이며, 함께 사용하는 라이브러리와 독립적으로 서비스되어 이를 사용하는 개발자가 선택적으로 사용하거나 그렇지 않을 수있다. </p>\n<br />\n<blockquote>\n<p>서버사이드 렌더링을 고려한 설계</p>\n</blockquote>\n<p align="center">\n<img src="https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/client-side-vs-server-side.png" width="600" height="450">\n</p>\n<p>서버 사이드 렌더링의 장점</p>\n<ul>\n<li>유저가 처음으로 컨텐츠를 보는 속도가 빨라짐</li>\n<li>서버따로 클라이언트따로 작성하던 코드가 하나로 합쳐짐</li>\n<li>SEO: SPA-API 방식의 애플리케이션의 단점을 보완</li>\n</ul>\n<br />\n<blockquote>\n<p>그리고 이 모든 것을 <code class="language-text">Javascript</code>로 개발 할 수있다.</p>\n</blockquote>\n<p><br /><br /><br /></p>',htmlAst:{type:"root",children:[{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"br",properties:{},children:[]},{type:"element",tagName:"br",properties:{},children:[]}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{align:"center"},children:[{type:"text",value:"\n"},{type:"element",tagName:"img",properties:{src:"https://www.import.io/wp-content/uploads/2017/10/React-logo-300x140.png"},children:[]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"br",properties:{},children:[]},{type:"element",tagName:"br",properties:{},children:[]}]},{type:"text",value:"\n"},{type:"element",tagName:"blockquote",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"최근 몇년 동안 웹개발 관련 기술은 수많은 변화를 격고있다."}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"어느 산업과 마찬가지로 기술을 이끌어가는 큰 벤더들이 서비스 하는 웹서비스에 발마추어 브라우져 버전 또한 과거에 비해 큰 규모의 업데이트가 적용 되고 있으며, 서버, 디바이스등 하드웨어의 발전과 맞물려 웹기술은 환경에 따른 한계에서 어느정도 자유로워진 부분도 큰 이유 중 하나이다. "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"그 변화의 중심에는 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"Javascript"}]},{type:"text",value:"가 있다고 해도 과언이 아닐것이다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"Javascript는 과거 HTML문서의 vaildation처리 정도의 수준에서 활용되었지만, 브라우져 없이 서버에서 작동하고 코드가 간결하며, 상대적으로 빠른 도입과 적용이 가능하게 되면서 많은 사이트가 자바스크립트 프레임 워크, 라이브러리를 사용하여 개발 되고 프레임워크가 변경되고 새로운 라이브러리가 나오고 있다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"프론트엔드에서  템플릿, 모델, 이벤트를 분리하여 Client side MVC패턴으로 개발을 할 수있는 "},{type:"element",tagName:"a",properties:{href:"https://backbonejs.org"},children:[{type:"text",value:"Backbone.js"}]},{type:"text",value:"라이브러리가 인기를 얻으면서 본격적인 프론트엔드 프레임워크들이 발표된다. 대표적으로 "},{type:"element",tagName:"a",properties:{href:"https://emberjs.com"},children:[{type:"text",value:"Ember"}]},{type:"text",value:", "},{type:"element",tagName:"a",properties:{href:"https://knockoutjs.com/"},children:[{type:"text",value:"Knockout"}]},{type:"text",value:" 그리고 "},{type:"element",tagName:"a",properties:{href:"https://Angularjs.org"},children:[{type:"text",value:"Angular JS"}]},{type:"text",value:"가 발표되어 끝판왕으로 군림한다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"AngularJS는 개발속도, Javascript의 코드량 축소, MVC패턴으로 얻는 장점(코드 컨벤션등) 그밖에 많은 장점을 갖고 있으며, 모바일에서 속도 문제, 러닝커브, 페이지 깜빡임, 뒤로가기시 새로로딩, 외부 서비스 콜백처리의 모호함 - 새로운 버전에서 많은 부분이 개선됨 - 등의 단점이 있다. 하지만 몇번의 업데이트 이슈와 여전히 존재하는 단점에도 불구하고 인기가 있고 여전히 많은 웹 서비스에서 사용되고 있다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"그리고 2013년 Facebook에서 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"React"}]},{type:"text",value:"를 발표한다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"React는 MVC프레임워크는 아니고 User Interface(View)를 만드는 라이브러리다. AngularJS처럼 MVC를 표방하는 것이 아니라 V(iew)에 집중하였고 훨씬 가볍다."}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"blockquote",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"React의 장점"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"- 쉽다(시작하기). 자바스크립트다. 당신이 ES6에 익숙하다면.(반대한다 이유는 React의 단점에서 기술)\n- 빠르다. DOM대신 Virtual DOM이라는 걸 이용하여 리플로우를 최소화한다.\n- 단순하다. 단방향 플로우로 프로젝트의 복잡성을 해소하고 Component를 구성하기 쉬움.\n- ES6지원 좋음\n- 일부페이지에 큰 수정없이 바로 적용할 수 있음 "}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"위 항목 중 무었보다 큰 장점을 꼽자면 단언 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"Virtual DOM"}]},{type:"text",value:" 이다."}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"blockquote",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"Virtual DOM "}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"Facebook에서는 DOM을 직접 변경하지 않고 내부적으로 빠르게 diff를 계산하는 알고리즘을 고안한다. \n마치 git을 사용하듯이 변경된 부분만 찾아서 빠르게 화면을 렌더링 할 수 있게 해준다."}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"브라우져는 보통 다음과 같은 과정을 통해 화면을 그려낸다."}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{align:"center"},children:[{type:"text",value:"\n"},{type:"element",tagName:"img",properties:{src:"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/webkitflow.png"},children:[]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"외부에서 DOM의 변경이 일어나면 DOM Tree를 재구성하고 Attachment하여 Render Tree를 재구성한다. 이때 브라우져가 판단하여 리플로(Layout), 리페인트(Painting)이 일어난다."}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"Virtual DOM을 사용한 React에서는 같은 간단한 예시로 어떻게 최적화하는지 볼 수있다."}]},{type:"text",value:"\n"},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"],dataLanguage:"text"},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"class Hello extends Component {\n    constructor(props) {\n        super(props);\n        ....\n    };\n    render() {\n        return(\n            // JSX\n            <react.fragment>\n                <div>Hello {this.props.personName} </div>\n                <div>My name is {this.state.name}</div>\n            </react.fragment>\n        );\n    }\n}"}]}]},{type:"text",value:"\n      "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"이 Hello 클래스는 만약 this.props.personName이 ‘James’이고 this.state.name이 ‘Jessie’ 라면 “Hello James” “My name is Jessie”라는 문자를 리턴하여 보여주는 컴포넌트 라고 하자.\n만약 "},{type:"element",tagName:"strong",properties:{},children:[{type:"text",value:"this.state.name"}]},{type:"text",value:"이 “Tom”으로 바뀐다면 당연히 “Hello James” “My name is Tom” 이렇게 출력 될 것이다. "}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"이때 React에서는 일반 브라우져의 리렌더링 과정과 다른 과정이 일어나는데 바로 Virtual DOM이 사용된다.\n기존 Component Tree의 DOM과 현재 변경된 Componenet를 비교하여 변경된 Component만 변경하고 DOM자체를 갱신한다.(심지어 알고리즘을 통해 비교하여 컴포넌트는 사라지지않고 속성값만 변경한다)"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"이로 인해 브라우져의 리플로를 최소화되고 성능을 최대화 할수있다."}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"프레임워크에 비해 상대적으로 가벼운 라이브러리이며, 함께 사용하는 라이브러리와 독립적으로 서비스되어 이를 사용하는 개발자가 선택적으로 사용하거나 그렇지 않을 수있다. "}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"blockquote",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"서버사이드 렌더링을 고려한 설계"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{align:"center"},children:[{type:"text",value:"\n"},{type:"element",tagName:"img",properties:{src:"https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/client-side-vs-server-side.png",width:600,height:450},children:[]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"서버 사이드 렌더링의 장점"}]},{type:"text",value:"\n"},{type:"element",tagName:"ul",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"유저가 처음으로 컨텐츠를 보는 속도가 빨라짐"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"서버따로 클라이언트따로 작성하던 코드가 하나로 합쳐짐"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"SEO: SPA-API 방식의 애플리케이션의 단점을 보완"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n"},{type:"element",tagName:"blockquote",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"그리고 이 모든 것을 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"Javascript"}]},{type:"text",value:"로 개발 할 수있다."}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"br",properties:{},children:[]},{type:"element",tagName:"br",properties:{},children:[]},{type:"element",tagName:"br",properties:{},children:[]}]}],data:{quirksMode:!1}},fields:{slug:"/Reactjs-Fundamental-1/",prefix:"2018-02-13"},frontmatter:{title:"Reactjs Fundamental 1",subTitle:"1. Javascript의 변화와 React",cover:{childImageSharp:{resize:{src:"/static/1200px-React-icon.svg-580ffd26ccaa16481ed87c1829c74943-160fa.png"}}}}},author:{id:"/Users/drugsism/Documents/Persnal/sopesnote/content/parts/author.md absPath of file >>> MarkdownRemark",html:"<p><strong>Sope</strong> Javascript Stack개발에 관심있는 웹 개발자입니다. 서비스 설계를 주로 하고, 모바일 생태계에도 관심이 많습니다.\n잘 치지 못하지만 기타연주를 취미로 가지고 있고, 가끔 초상화를 그리기도 합니다.</p>"},footnote:{id:"/Users/drugsism/Documents/Persnal/sopesnote/content/parts/footnote.md absPath of file >>> MarkdownRemark",html:'<ul>\n<li>\n<p>All constent copyright 2018 powerd by sope All right reserved</p>\n</li>\n<li>\n<p>built with <a href="https://www.gatsbyjs.org">Gatsby</a> &#x26; <a href="https://reactjs.org/">React</a></p>\n</li>\n<li>\n<p>delivered by <a href="https://pages.github.com/">Github pages</a></p>\n</li>\n</ul>'},site:{siteMetadata:{facebook:{appId:"..."}}}},pathContext:{slug:"/Reactjs-Fundamental-1/"}}}});
//# sourceMappingURL=path---reactjs-fundamental-1-594962fd94a3a9ad036c.js.map